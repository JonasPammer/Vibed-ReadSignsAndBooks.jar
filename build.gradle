plugins {
    id 'java'
    id 'application'
    id 'groovy'
    id 'org.openjfx.javafxplugin' version '0.1.0'
    id 'com.github.jk1.dependency-license-report' version '3.0.1'
    id 'org.beryx.runtime' version '1.13.1'
    id 'com.gorylenko.gradle-git-properties' version '2.5.0'
    id 'jacoco'
}

group = 'com.minecraftdatamining'

sourceCompatibility = '21'
targetCompatibility = '21'

// Shared constants to avoid DuplicateListLiteral violations
List<String> groovySourceDirs = ['src/main/groovy']
List<String> defaultJvmArgs = ['-Xmx10G', '-XX:+UseG1GC', '-XX:MaxGCPauseMillis=200']

// Specify source directory (now using standard Maven/Gradle layout)
sourceSets {
    main {
        groovy {
            srcDirs = groovySourceDirs
        }
        java {
            srcDirs = ['src/main/java']
        }
        resources {
            srcDirs = ['src/main/resources']
        }
    }
    test {
        groovy {
            srcDirs = ['src/test/groovy']
        }
        resources {
            srcDirs = ['src/test/resources']
        }
    }
}

repositories {
    mavenCentral()
    maven { url 'https://jitpack.io' }
}

javafx {
    version = '21.0.5'
    modules = ['javafx.controls', 'javafx.fxml', 'javafx.graphics', 'javafx.swing']
}

dependencies {
    // Groovy - for main application code
    implementation 'org.apache.groovy:groovy:4.0.24'
    implementation 'org.apache.groovy:groovy-json:4.0.24'
    implementation 'org.apache.groovy:groovy-sql:4.0.24'

    // Apache Commons IO - simplifies file operations
    implementation 'commons-io:commons-io:2.18.0'

    // Apache Commons Lang - for duration formatting
    implementation 'org.apache.commons:commons-lang3:3.17.0'

    // Picocli for command-line argument parsing (annotation-based, modern)
    implementation 'info.picocli:picocli:4.7.7'

    // Querz NBT library - Complete NBT + MCA/Region file support
    implementation 'com.github.Querz:NBT:6.1'

    // JSON library - for parsing Minecraft JSON text components
    implementation 'org.json:json:20250517'

    // SLF4J API for logging
    implementation 'org.slf4j:slf4j-api:2.0.16'

    // Logback as SLF4J implementation
    implementation 'ch.qos.logback:logback-classic:1.5.12'

    // Progress bar library for console output
    implementation 'me.tongfei:progressbar:0.10.1'

    // ASCII table library for formatted output
    implementation 'com.github.freva:ascii-table:1.8.0'

    // SQLite JDBC driver for block index database
    implementation 'org.xerial:sqlite-jdbc:3.45.1.0'

    // JavaFX modules handled by javafxplugin above (no GroovyFX needed - using pure JavaFX with Groovy syntax)

    // System theme detection for automatic dark mode
    implementation 'org.openani.jsystemthemedetector:jSystemThemeDetector:3.8'

    // Modern JavaFX theme library with built-in dark/light themes
    implementation 'io.github.mkpaz:atlantafx-base:2.1.0'

    // Spock Framework for testing
    testImplementation 'org.spockframework:spock-core:2.3-groovy-4.0'
    testImplementation 'org.apache.groovy:groovy-all:4.0.24'

    // JUnit Platform for running Spock tests
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'

    // TestFX for JavaFX GUI testing
    testImplementation 'org.testfx:testfx-core:4.0.18'
    testImplementation 'org.testfx:testfx-spock:4.0.18'

// Note: Monocle for headless testing is NOT compatible with JavaFX 21 yet
// See: https://github.com/TestFX/Monocle/issues
// GUI tests will run in headed mode when a display is available
}

application {
    mainClass = 'Main'  // Auto-detects GUI vs CLI mode
    applicationDefaultJvmArgs = defaultJvmArgs
}

tasks.withType(JavaCompile) {
    options.encoding = 'UTF-8'
}

jar {
    manifest {
        attributes(
                'Main-Class': 'Main'
        )
    }
    archiveFileName = 'ReadSignsAndBooks.jar'

    // Include dependencies in the JAR (fat JAR)
    from {
        configurations.runtimeClasspath.collect { file -> file.directory ? file : zipTree(file) }
    }

    duplicatesStrategy = DuplicatesStrategy.EXCLUDE

    // Copy the JAR to root directory after creation
    doLast {
        copy {
            from "$buildDir/libs/ReadSignsAndBooks.jar"
            into projectDir
        }
    }
}

// Configure test task
test {
    useJUnitPlatform()
    finalizedBy jacocoTestReport // Generate coverage report after tests

    testLogging {
        events 'passed', 'skipped', 'failed'
        exceptionFormat 'full'
        showStandardStreams = true
    }

    // Increase test timeout for integration tests (allows for multiple test world files)
    timeout = java.time.Duration.ofMinutes(30)

    // JavaFX GUI testing configuration
    // Note: Monocle headless testing is not compatible with JavaFX 21 yet
    // Tests run in headed mode when display is available, skip otherwise
    jvmArgs = [
        '-Dtestfx.robot=awt',  // Use AWT robot (more compatible than Glass)
        '-Dprism.order=sw',    // Software rendering for consistency
        '-Dprism.text=t2k'
    ]
}

// JaCoCo configuration
jacoco {
    toolVersion = '0.8.11'
}

jacocoTestReport {
    // Generate report from existing coverage data (does NOT re-run tests)
    // Coverage data is created during test execution and stored in build/jacoco/test.exec
    // To generate report: ./gradlew test (creates coverage data) then ./gradlew jacocoTestReport
    // Or run both: ./gradlew test jacocoTestReport
    dependsOn test // Ensure tests run before generating report

    reports {
        xml.required = true // Required for Codecov
        html.required = true // Human-readable HTML report
        csv.required = false
    }

    // Explicitly configure for Groovy source files
    afterEvaluate {
        // Include Groovy source directories
        sourceDirectories.setFrom(files(groovySourceDirs))

        // Include Groovy compiled classes
        classDirectories.setFrom(files([
            fileTree(dir: "${buildDir}/classes/groovy/main", exclude: [
                '**/Main.class',  // Exclude Main class if needed
            ])
        ]))

        // Ensure execution data is collected from test task
        executionData.setFrom(fileTree(dir: "${buildDir}/jacoco", include: 'test.exec'))
    }
}

// Task to generate coverage report (can be run independently)
tasks.named('jacocoTestReport') {
    group = 'verification'
    description = 'Generates code coverage report from test execution'
}

// Task to print coverage summary
task printCoverage {
    dependsOn jacocoTestReport
    group = 'verification'
    description = 'Prints code coverage summary to console'

    doLast {
        File reportFile = file("${buildDir}/reports/jacoco/test/jacocoTestReport.xml")
        if (reportFile.exists()) {
            XmlParser parser = new XmlParser()
            parser.setFeature('http://apache.org/xml/features/disallow-doctype-decl', false)
            parser.setFeature('http://xml.org/sax/features/external-general-entities', false)
            parser.setFeature('http://xml.org/sax/features/external-parameter-entities', false)
            Node report = parser.parse(reportFile)
            Object counter = report.counter.find { Object node -> node.'@type' == 'INSTRUCTION' }
            if (counter) {
                Integer missed = counter.'@missed' as Integer
                Integer covered = counter.'@covered' as Integer
                Integer total = missed + covered
                Number percentage = total > 0 ? (covered * 100.0 / total).round(2) : 0

                println '\n' + '=' * 60
                println 'CODE COVERAGE SUMMARY'
                println '=' * 60
                println "Instructions: ${covered}/${total} (${percentage}%)"

                ['BRANCH', 'LINE', 'METHOD', 'CLASS'].each { String type ->
                    Object typeCounter = report.counter.find { Object node -> node.'@type' == type }
                    if (typeCounter) {
                        Integer tMissed = typeCounter.'@missed' as Integer
                        Integer tCovered = typeCounter.'@covered' as Integer
                        Integer tTotal = tMissed + tCovered
                        Number tPercentage = tTotal > 0 ? (tCovered * 100.0 / tTotal).round(2) : 0
                        println "${type.padRight(12)}: ${tCovered}/${tTotal} (${tPercentage}%)"
                    }
                }
                println '=' * 60 + '\n'
            }
        } else {
            println "Coverage report not found. Run 'gradlew test jacocoTestReport' first."
        }
    }
}

// License report configuration
import com.github.jk1.license.render.TextReportRenderer

licenseReport {
    outputDir = "$projectDir/src/main/resources/licenses"
    renderers = [new TextReportRenderer('THIRD-PARTY-LICENSES.txt')]
    configurations = ['runtimeClasspath']
}

// Ensure licenses directory exists before generating report
tasks.register('ensureLicensesDir') {
    doLast {
        file("$projectDir/src/main/resources/licenses").mkdirs()
    }
}

// Generate license report before building JAR
tasks.named('generateLicenseReport') {
    dependsOn 'ensureLicensesDir'
}

tasks.named('processResources') {
    dependsOn 'generateLicenseReport'
}

// Configure gradle-git-properties plugin
gitProperties {
    // Only include the properties we need
    keys = ['git.commit.id.abbrev', 'git.commit.time', 'git.remote.origin.url']
    dateFormat = "yyyy-MM-dd"
    dateFormatTimeZone = "UTC"
    // Add build time as custom property
    customProperty 'git.build.time', { new java.text.SimpleDateFormat('yyyy-MM-dd').format(new Date()) }
}

// jpackage configuration for Windows distribution
runtime {
    options = ['--strip-debug', '--compress', '2', '--no-header-files', '--no-man-pages']

    modules = [
        'java.base',
        'java.desktop',
        'java.logging',
        'java.management',
        'java.naming',
        'java.prefs',
        'java.sql',
        'java.xml',
        'jdk.unsupported'
    ]

    jpackage {
        imageName = 'ReadSignsAndBooks'
        imageOptions = ['--icon', 'src/main/resources/icons/icon.ico']

        jvmArgs = defaultJvmArgs
    }
}

// Task to build Windows distribution and create ZIP
task createWindowsZip {
    dependsOn 'jpackageImage'
    description = 'Creates Windows distribution ZIP for releases'
    group = 'distribution'

    doLast {
        File jpackageDir = file("$buildDir/jpackage/ReadSignsAndBooks")
        File zipFile = file('ReadSignsAndBooks-Windows.zip')

        if (jpackageDir.exists()) {
            // Create ZIP file
            ant.zip(destfile: zipFile.absolutePath, basedir: jpackageDir.absolutePath)

            println "✅ Windows distribution ZIP created: ${zipFile.absolutePath}"
            println "   Size: ${zipFile.length() / 1024 / 1024} MB"
            println '   Contents: EXE + bundled JRE'
            println '   • Users extract ZIP and double-click ReadSignsAndBooks.exe'
        } else {
            println "⚠️  jpackage output not found at: ${jpackageDir.absolutePath}"
        }
    }
}
